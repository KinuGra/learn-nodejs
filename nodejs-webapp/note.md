# バックエンドフレームワークの特徴
## TypeScript（Express）
特徴：自由度が高く、開発が爆速
向いている用途：MVP開発、BFF、小規模API

## TypeScript（NestJS）
特徴：開発のルールが厳格
向いている用途：中～大規模のチーム開発

## FastAPI
特徴：AIライブラリとの親和性が最強
向いている用途：AI活用、データ分析系

## Go（Gin/Fiber）
特徴：軽量・爆速・低コスト
向いている用途：マイクロサービス、高トラフィック

## Java / Kotlin
特徴：実績No.1、型が極めて強固
向いている用途：金融、大規模エンタープライズ

## 大規模プロダクトはNode.jsではだめなのか
- 複雑な計算はシングルスレッドでは限界がくる
- Goなどはメモリ効率がよく、サーバー台数を減らして単位のインフラコストを削れる
- JavaやKotlinのような厳格な型がある方が他人のコードを壊さずに安全に修正できる

# Webサーバー
Node.jsは内部でV8（JSエンジン）、libuv（非同期I/Oライブラリ）、C/C++で書かれた標準モジュール群で構成される。
`const http = require("http")` でNode.jsに組み込まれているHTTPモジュールを読み込んでいる
このモジュールはTCP通信を扱う、HTTPメッセージをパースするなどの機能がある

Nodeは内部でOSのシステムコールを使ってTCPソケットを作り、受信待ちをしている
つまりOSの機能を使ってTCP通信をしている（NodeがTCPを実装しているわけではない）

1. socket()：OSに通信口を作ってと頼む
2. bind()：ポート3000に結び付ける
3. listen()：接続待ち状態にする
4. accept()：接続が来たら受け入れる
5. read()：データ受信
6. write()：データ送信
これらは全てOSのシステムコール

`http.createSerer((req, res) => {...})`
1. TCPサーバーを作る
2. 接続が来たらHTTPとして解析
3. HTTPヘッダをパース
4. req と res オブジェクトを作る
5. コールバックを実行
コールバックは`(req, res) => {...}`
HTTPリクエストが届いたらこの関数を実行してという意味

TCPサーバーとHTTPサーバーの違い
- TCPサーバー
  - 生のデータを扱う
  - HTTPの概念はない
  - バイト列をそのまま送受信
- HTTPサーバー
  - TCPの上にHTTPプロトコルを実装
  - ヘッダ解析
  - ステータスコード管理
つまりHTTPはTCPの上で動くプロトコル

自作する難易度はTCPクライアント < TCPサーバー < HTTPクライアント < HTTPサーバー < HTTP1.1実装 < HTTP2/3実装

`response.end()は何を閉じるのか`
これはHTTPレスポンスの送信を終了する
つまり、データ送信完了、必要ならTCP接続を閉じる
クライアントはヘッダー、ボディ、送信終了を待っているので`end()`を呼ばないと、まだデータが来るのかな？と待ち続ける

`server.listen(port)`
これはOSに「このポートで接続待ちする」登録する
listenはサーバー起動、response.endはレスポンスを終了

`server.listen(3000);`
内部では何が起きているのか
1. TCPソケット作成
Node内部（C++）で`socket(AF_INET, SOCK_STREAM, 0)`
というOSのシステムコールを呼ぶ
意味：「通信口を作ってください」
1. ポートに結び付ける（bind）
`bind(socket, 0.0.0.0:3000)`
意味：「このソケットを3000番ポートに紐付けてください」
これでOSのポート表に3000→このプロセスが登録される
1. listen（接続待ち状態）
`listen(socket, backlog)`
意味：「接続要求を待ちます」
この状態で、ブラウザがアクセスすると
`SYN → SYN/ACK → ACK`
というTCPの3wayハンドシェイクが発生する
1. イベントループで待機
Nodeはlibuvというライブラリを使っている
libuvは「接続が来たら教えて」とOSに登録する
これがイベントループ

イベントループとは？
Nodeはシングルスレッド、ノンブロッキングI/O
つまり「ずっとwhile(true)のように監視している」わけではない
OSが接続きたよと通知してくれる
そのときlibuvが検知し、NodeのC++層が受信、JavaScriptのコールバック実行

TCP通信しているの？
ブラウザ → TCPパケット送信
OS → 受信
Node → データ取得
という流れ
NodeがTCPを自分で実装しているわけではない。
OSのTCPスタックを使っている

C++で実装されたbinaryをnode.jsで読み込めるのか
1. Nodeの標準モジュール（httpなど）
これはNode本体にC++で組み込まれている
JavaScriptから呼べるようにラップされている
`JS → C++ → OS`という構造
2. ネイティブアドオン（C++拡張）
自分でC++を書いて`node-gyp`でビルドすると`.node`というバイナリができる
それを`require('./addon.node');`で読み込める
これはJSからC++をよぶ仕組み
